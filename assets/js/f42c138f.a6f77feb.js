"use strict";(globalThis.webpackChunktextbook=globalThis.webpackChunktextbook||[]).push([[370],{3023:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>o});var s=t(3696);const i={},r=s.createContext(i);function a(e){const n=s.useContext(r);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),s.createElement(r.Provider,{value:n},e.children)}},4366:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>m,frontMatter:()=>a,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"ros2/topics-rclpy","title":"ROS 2 Topics and rclpy: Deep Dive into Communication","description":"Learning Objectives","source":"@site/docs/ros2/topics-rclpy.md","sourceDirName":"ros2","slug":"/ros2/topics-rclpy","permalink":"/AI-Book/docs/ros2/topics-rclpy","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/ros2/topics-rclpy.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2},"sidebar":"tutorialSidebar","previous":{"title":"Introduction to ROS 2: Foundation of Modern Robotics","permalink":"/AI-Book/docs/ros2/introduction"},"next":{"title":"URDF: Unified Robot Description Format for Physical AI Systems","permalink":"/AI-Book/docs/ros2/urdf-modelling"}}');var i=t(2540),r=t(3023);const a={sidebar_position:2},o="ROS 2 Topics and rclpy: Deep Dive into Communication",l={},c=[{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Real-World Context",id:"real-world-context",level:2},{value:"Advanced Publisher-Subscriber Patterns",id:"advanced-publisher-subscriber-patterns",level:2},{value:"Quality of Service (QoS) Profiles",id:"quality-of-service-qos-profiles",level:2},{value:"Custom Message Types",id:"custom-message-types",level:2},{value:"Advanced rclpy Features",id:"advanced-rclpy-features",level:2},{value:"Timers and Callback Groups",id:"timers-and-callback-groups",level:2},{value:"Working with Time and Timeouts",id:"working-with-time-and-timeouts",level:2},{value:"Conclusion",id:"conclusion",level:2},{value:"Exercises",id:"exercises",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"ros-2-topics-and-rclpy-deep-dive-into-communication",children:"ROS 2 Topics and rclpy: Deep Dive into Communication"})}),"\n",(0,i.jsx)(n.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,i.jsx)(n.p,{children:"By the end of this chapter, you will be able to:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Implement advanced publisher-subscriber patterns in ROS 2"}),"\n",(0,i.jsx)(n.li,{children:"Utilize rclpy for complex node communication scenarios"}),"\n",(0,i.jsx)(n.li,{children:"Configure Quality of Service settings for different communication needs"}),"\n",(0,i.jsx)(n.li,{children:"Create custom message types for specialized applications"}),"\n",(0,i.jsx)(n.li,{children:"Implement latching and transient local communication patterns"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"real-world-context",children:"Real-World Context"}),"\n",(0,i.jsx)(n.p,{children:"Understanding advanced ROS 2 communication patterns is crucial for developing robust robotic systems. In real-world applications, different types of data require different communication characteristics. Sensor data might need real-time delivery with best-effort reliability, while critical control commands might require guaranteed delivery. The ability to configure these patterns appropriately can mean the difference between a successful robotic deployment and one that fails under operational conditions."}),"\n",(0,i.jsx)(n.p,{children:"Industrial robots, autonomous vehicles, and humanoid robots all rely on carefully designed communication patterns to coordinate complex behaviors. For example, a humanoid robot walking through a room needs to balance real-time sensor processing with reliable command execution to actuators, requiring different QoS settings for different data streams."}),"\n",(0,i.jsx)(n.h2,{id:"advanced-publisher-subscriber-patterns",children:"Advanced Publisher-Subscriber Patterns"}),"\n",(0,i.jsx)(n.p,{children:"ROS 2 provides several advanced patterns beyond the basic publisher-subscriber model to handle complex communication requirements. These include latched topics for providing initial state to new subscribers, transient local durability for persistent state, and various reliability and deadline settings."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Figure: Advanced ROS 2 communication patterns showing latched topics and QoS settings"})," - This diagram illustrates different communication patterns: a latched topic that maintains the last published message for new subscribers, a best-effort topic for sensor data where occasional packet loss is acceptable, and a reliable topic for critical commands where all messages must be delivered."]}),"\n",(0,i.jsx)(n.p,{children:"Latched topics are particularly useful for state information that new subscribers need to know immediately upon connecting. For example, a robot's current pose or configuration parameters might be published to a latched topic so that any new node that subscribes immediately receives the current state rather than waiting for the next update."}),"\n",(0,i.jsx)(n.p,{children:"Here's an example of implementing a latched publisher:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom std_msgs.msg import String\nfrom rclpy.qos import QoSProfile, QoSDurabilityPolicy\n\n\nclass LatchedPublisher(Node):\n\n    def __init__(self):\n        super().__init__('latched_publisher')\n\n        # Create a QoS profile with transient local durability for latching\n        qos_profile = QoSProfile(\n            depth=10,\n            durability=QoSDurabilityPolicy.TRANSIENT_LOCAL\n        )\n\n        self.publisher_ = self.create_publisher(String, 'latched_topic', qos_profile)\n\n        # Publish initial state\n        msg = String()\n        msg.data = 'Initial robot state: IDLE'\n        self.publisher_.publish(msg)\n\n        # Timer for periodic updates\n        timer_period = 1.0  # seconds\n        self.timer = self.create_timer(timer_period, self.timer_callback)\n        self.state_counter = 0\n\n    def timer_callback(self):\n        msg = String()\n        states = ['IDLE', 'ACTIVE', 'BUSY', 'ERROR']\n        msg.data = f'Robot state: {states[self.state_counter % len(states)]}'\n        self.publisher_.publish(msg)\n        self.get_logger().info(f'Publishing: \"{msg.data}\"')\n        self.state_counter += 1\n\n\nclass LatchedSubscriber(Node):\n\n    def __init__(self):\n        super().__init__('latched_subscriber')\n\n        # Same QoS profile as publisher\n        qos_profile = QoSProfile(\n            depth=10,\n            durability=QoSDurabilityPolicy.TRANSIENT_LOCAL\n        )\n\n        self.subscription = self.create_subscription(\n            String,\n            'latched_topic',\n            self.listener_callback,\n            qos_profile\n        )\n        self.subscription  # prevent unused variable warning\n\n    def listener_callback(self, msg):\n        self.get_logger().info(f'Received latched state: \"{msg.data}\"')\n\n\ndef main(args=None):\n    rclpy.init(args=args)\n\n    latched_publisher = LatchedPublisher()\n    latched_subscriber = LatchedSubscriber()\n\n    # Use MultiThreadedExecutor to run both nodes simultaneously\n    executor = rclpy.executors.MultiThreadedExecutor()\n    executor.add_node(latched_publisher)\n    executor.add_node(latched_subscriber)\n\n    try:\n        executor.spin()\n    finally:\n        executor.shutdown()\n        latched_publisher.destroy_node()\n        latched_subscriber.destroy_node()\n        rclpy.shutdown()\n"})}),"\n",(0,i.jsx)(n.h2,{id:"quality-of-service-qos-profiles",children:"Quality of Service (QoS) Profiles"}),"\n",(0,i.jsx)(n.p,{children:"Quality of Service profiles in ROS 2 provide fine-grained control over communication characteristics, which is essential for real-time robotic systems. The four main QoS settings are reliability, durability, history, and liveliness, each addressing different aspects of communication requirements."}),"\n",(0,i.jsx)(n.p,{children:"Reliability controls whether messages are guaranteed to be delivered. RELIABLE ensures all messages are delivered (with potential delays), while BEST_EFFORT prioritizes timeliness over delivery guarantee. For sensor data like camera feeds or LIDAR scans, BEST_EFFORT is often appropriate since occasional dropped frames are acceptable. For critical control commands, RELIABLE is essential."}),"\n",(0,i.jsx)(n.p,{children:"Durability determines how messages persist for late-joining subscribers. VOLATILE means messages are only sent to currently connected subscribers, while TRANSIENT_LOCAL means the publisher stores messages and sends them to new subscribers when they join."}),"\n",(0,i.jsx)(n.p,{children:"History controls how many messages are stored for delivery. KEEP_LAST maintains a fixed-size queue of the most recent messages, while KEEP_ALL stores all messages (with memory implications)."}),"\n",(0,i.jsx)(n.p,{children:"Here's an example of using different QoS profiles for different data types:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom sensor_msgs.msg import LaserScan\nfrom geometry_msgs.msg import Twist\nfrom std_msgs.msg import String\nfrom rclpy.qos import QoSProfile, ReliabilityPolicy, HistoryPolicy, DurabilityPolicy\n\n\nclass QoSDemoNode(Node):\n\n    def __init__(self):\n        super().__init__('qos_demo_node')\n\n        # Sensor data: best-effort, volatile, keep last 10\n        sensor_qos = QoSProfile(\n            depth=10,\n            reliability=ReliabilityPolicy.BEST_EFFORT,\n            durability=DurabilityPolicy.VOLATILE,\n            history=HistoryPolicy.KEEP_LAST\n        )\n        self.sensor_publisher = self.create_publisher(LaserScan, 'sensor_scan', sensor_qos)\n\n        # Control commands: reliable, volatile, keep last 1\n        control_qos = QoSProfile(\n            depth=1,\n            reliability=ReliabilityPolicy.RELIABLE,\n            durability=DurabilityPolicy.VOLATILE,\n            history=HistoryPolicy.KEEP_LAST\n        )\n        self.control_publisher = self.create_publisher(Twist, 'cmd_vel', control_qos)\n\n        # System status: reliable, transient local, keep last 1\n        status_qos = QoSProfile(\n            depth=1,\n            reliability=ReliabilityPolicy.RELIABLE,\n            durability=DurabilityPolicy.TRANSIENT_LOCAL,\n            history=HistoryPolicy.KEEP_LAST\n        )\n        self.status_publisher = self.create_publisher(String, 'system_status', status_qos)\n\n        # Create timers for different types of publications\n        self.sensor_timer = self.create_timer(0.1, self.publish_sensor_data)  # 10Hz\n        self.control_timer = self.create_timer(0.05, self.publish_control_command)  # 20Hz\n        self.status_timer = self.create_timer(1.0, self.publish_status)  # 1Hz\n\n    def publish_sensor_data(self):\n        # Simulate sensor data publication with best-effort QoS\n        msg = LaserScan()\n        msg.header.stamp = self.get_clock().now().to_msg()\n        msg.header.frame_id = 'laser_frame'\n        # ... populate laser scan data\n        self.sensor_publisher.publish(msg)\n\n    def publish_control_command(self):\n        # Simulate control command with reliable QoS\n        msg = Twist()\n        msg.linear.x = 0.5  # Move forward at 0.5 m/s\n        msg.angular.z = 0.1  # Turn slightly right\n        self.control_publisher.publish(msg)\n\n    def publish_status(self):\n        # Publish system status with transient local QoS\n        msg = String()\n        msg.data = 'System operational - OK'\n        self.status_publisher.publish(msg)\n"})}),"\n",(0,i.jsx)(n.h2,{id:"custom-message-types",children:"Custom Message Types"}),"\n",(0,i.jsxs)(n.p,{children:["Custom message types allow you to define application-specific data structures that can be shared between nodes. These are defined in ",(0,i.jsx)(n.code,{children:".msg"})," files and compiled into language-specific interfaces. Creating well-designed custom messages is crucial for efficient communication in complex robotic systems."]}),"\n",(0,i.jsxs)(n.p,{children:["To create a custom message, first create a ",(0,i.jsx)(n.code,{children:"msg"})," directory in your package and define the message structure:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"# In msg/RobotState.msg\nstd_msgs/Header header\nfloat64 position_x\nfloat64 position_y\nfloat64 position_z\nfloat64 orientation_x\nfloat64 orientation_y\nfloat64 orientation_z\nfloat64 orientation_w\nstring status\nuint8[] joint_angles\nfloat64[5] sensor_readings\n"})}),"\n",(0,i.jsx)(n.p,{children:"Then in your Python code, you can use the custom message:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom std_msgs.msg import Header\nfrom your_package_msgs.msg import RobotState  # Custom message type\n\n\nclass RobotStatePublisher(Node):\n\n    def __init__(self):\n        super().__init__('robot_state_publisher')\n        self.publisher_ = self.create_publisher(RobotState, 'robot_state', 10)\n        timer_period = 0.1  # seconds\n        self.timer = self.create_timer(timer_period, self.publish_robot_state)\n\n    def publish_robot_state(self):\n        msg = RobotState()\n        msg.header.stamp = self.get_clock().now().to_msg()\n        msg.header.frame_id = 'base_link'\n\n        # Populate robot state\n        msg.position_x = 1.0\n        msg.position_y = 2.0\n        msg.position_z = 0.0\n        msg.orientation_x = 0.0\n        msg.orientation_y = 0.0\n        msg.orientation_z = 0.0\n        msg.orientation_w = 1.0\n        msg.status = 'ACTIVE'\n\n        # Joint angles (example: 6 joints)\n        msg.joint_angles = [45, 30, 90, 0, -45, 15]  # in degrees\n\n        # Sensor readings (example: 5 sensors)\n        msg.sensor_readings = [1.2, 3.4, 5.6, 7.8, 9.0]\n\n        self.publisher_.publish(msg)\n"})}),"\n",(0,i.jsx)(n.h2,{id:"advanced-rclpy-features",children:"Advanced rclpy Features"}),"\n",(0,i.jsx)(n.p,{children:"The rclpy library provides several advanced features beyond basic publishing and subscribing, including parameter callbacks, lifecycle nodes, and custom executors. These features enable more sophisticated node behaviors and system management."}),"\n",(0,i.jsx)(n.p,{children:"Parameter callbacks allow nodes to react dynamically to parameter changes without restarting:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom rclpy.parameter import Parameter\n\n\nclass DynamicParameterNode(Node):\n\n    def __init__(self):\n        super().__init__('dynamic_parameter_node')\n\n        # Declare parameters with default values\n        self.declare_parameter('control_gain', 1.0)\n        self.declare_parameter('max_velocity', 1.0)\n        self.declare_parameter('operation_mode', 'manual')\n\n        # Set callback for parameter changes\n        self.add_on_set_parameters_callback(self.parameter_callback)\n\n        # Initialize with current parameter values\n        self.control_gain = self.get_parameter('control_gain').value\n        self.max_velocity = self.get_parameter('max_velocity').value\n        self.operation_mode = self.get_parameter('operation_mode').value\n\n        self.get_logger().info(f'Initialized with gain: {self.control_gain}, max vel: {self.max_velocity}')\n\n    def parameter_callback(self, params):\n        for param in params:\n            if param.name == 'control_gain':\n                self.control_gain = param.value\n                self.get_logger().info(f'Control gain updated to: {self.control_gain}')\n            elif param.name == 'max_velocity':\n                self.max_velocity = param.value\n                self.get_logger().info(f'Max velocity updated to: {self.max_velocity}')\n            elif param.name == 'operation_mode':\n                self.operation_mode = param.value\n                self.get_logger().info(f'Operation mode updated to: {self.operation_mode}')\n\n        return SetParametersResult(successful=True)\n"})}),"\n",(0,i.jsx)(n.h2,{id:"timers-and-callback-groups",children:"Timers and Callback Groups"}),"\n",(0,i.jsx)(n.p,{children:"ROS 2 provides advanced timer functionality that allows for precise timing control and coordination between different callbacks. Callback groups enable you to control the threading model of your node, determining which callbacks can run concurrently."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom rclpy.callback_groups import MutuallyExclusiveCallbackGroup, ReentrantCallbackGroup\nfrom rclpy.executors import MultiThreadedExecutor\n\n\nclass AdvancedTimersNode(Node):\n\n    def __init__(self):\n        super().__init__('advanced_timers_node')\n\n        # Create different callback groups\n        self.group1 = MutuallyExclusiveCallbackGroup()\n        self.group2 = MutuallyExclusiveCallbackGroup()\n        self.group3 = ReentrantCallbackGroup()  # Can run concurrently with others\n\n        # Create timers with different callback groups\n        self.timer1 = self.create_timer(\n            0.1,  # 10 Hz\n            self.high_freq_callback,\n            callback_group=self.group1\n        )\n\n        self.timer2 = self.create_timer(\n            1.0,  # 1 Hz\n            self.low_freq_callback,\n            callback_group=self.group2\n        )\n\n        self.pub_timer = self.create_timer(\n            0.5,  # 2 Hz\n            self.publisher_callback,\n            callback_group=self.group3\n        )\n\n    def high_freq_callback(self):\n        self.get_logger().info('High frequency callback executing')\n\n    def low_freq_callback(self):\n        self.get_logger().info('Low frequency callback executing')\n\n    def publisher_callback(self):\n        # This can run concurrently with other callbacks due to ReentrantCallbackGroup\n        self.get_logger().info('Publisher callback executing')\n"})}),"\n",(0,i.jsx)(n.h2,{id:"working-with-time-and-timeouts",children:"Working with Time and Timeouts"}),"\n",(0,i.jsx)(n.p,{children:"Proper time handling is critical in robotic systems where synchronization between different components is essential. ROS 2 provides sophisticated time management capabilities:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom rclpy.time import Time, Duration\nfrom rclpy.clock import Clock, ClockType\n\n\nclass TimeManagementNode(Node):\n\n    def __init__(self):\n        super().__init__('time_management_node')\n\n        # Create a clock instance\n        self.clock = Clock(clock_type=ClockType.ROS_TIME)\n\n        # Track execution times\n        self.last_execution_time = self.clock.now()\n\n        # Create timer for periodic execution\n        self.timer = self.create_timer(0.1, self.periodic_task)\n\n    def periodic_task(self):\n        current_time = self.clock.now()\n        time_since_last = current_time - self.last_execution_time\n\n        # Log execution interval\n        self.get_logger().info(f'Task executed after {(time_since_last.nanoseconds / 1e9):.3f}s')\n\n        # Example: timeout logic\n        if time_since_last > Duration(seconds=0.2):\n            self.get_logger().warn('Execution took longer than expected!')\n\n        # Update last execution time\n        self.last_execution_time = current_time\n\n        # Perform actual task\n        self.perform_computation()\n\n    def perform_computation(self):\n        # Simulate some computation\n        import time\n        time.sleep(0.01)  # 10ms computation\n"})}),"\n",(0,i.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,i.jsx)(n.p,{children:"Advanced ROS 2 communication patterns and rclpy features provide the tools necessary to build sophisticated, reliable robotic systems. Understanding Quality of Service settings, custom message types, parameter management, and timing mechanisms is essential for creating applications that can handle the diverse requirements of real-world robotic systems."}),"\n",(0,i.jsx)(n.p,{children:"The ability to configure different communication characteristics for different types of data allows you to optimize your robotic system for performance, reliability, and real-time requirements. In the next chapter, we'll explore URDF in greater detail and learn how to create complex robot models for simulation and control."}),"\n",(0,i.jsx)(n.h2,{id:"exercises",children:"Exercises"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Create a ROS 2 node that publishes sensor data with BEST_EFFORT QoS and another that subscribes with appropriate settings, measuring the actual delivery rate."}),"\n",(0,i.jsx)(n.li,{children:"Implement a custom message type for a mobile robot's odometry that includes position, velocity, and covariance information."}),"\n",(0,i.jsx)(n.li,{children:"Design a parameter configuration system that allows runtime adjustment of PID controller gains."}),"\n",(0,i.jsx)(n.li,{children:"Implement a time-synchronized publisher that ensures messages are published at precise intervals despite variable computation times."}),"\n"]})]})}function m(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}}}]);